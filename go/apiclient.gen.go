// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"gopkg.in/yaml.v2"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// AllUserCountersResponse defines model for AllUserCountersResponse.
type AllUserCountersResponse struct {
	// CounterId ID of the counter type
	CounterId string `json:"counter_id"`

	// Limit Maximum number of users returned
	Limit int `json:"limit"`

	// Offset Number of users skipped
	Offset int `json:"offset"`

	// TotalCount Total number of users (for pagination)
	TotalCount int `json:"total_count"`

	// Users List of users with their counter balances
	Users []UserCountersResponse `json:"users"`
}

// AvailableCountersResponse defines model for AvailableCountersResponse.
type AvailableCountersResponse struct {
	// Counters List of available counter type IDs
	Counters []string `json:"counters"`
}

// CounterAdjustmentRequest defines model for CounterAdjustmentRequest.
type CounterAdjustmentRequest struct {
	// Amount Amount to add (positive) or deduct (negative)
	Amount int `json:"amount"`

	// Description Description of the counter adjustment
	Description string `json:"description"`
}

// CounterHistoryResponse defines model for CounterHistoryResponse.
type CounterHistoryResponse struct {
	// CounterId ID of the counter type
	CounterId string `json:"counter_id"`

	// CurrentBalance Current counter balance
	CurrentBalance int `json:"current_balance"`

	// Limit Maximum number of transactions returned
	Limit int `json:"limit"`

	// Offset Number of transactions skipped
	Offset int `json:"offset"`

	// TotalCount Total number of transactions (for pagination)
	TotalCount int `json:"total_count"`

	// Transactions List of counter transactions
	Transactions []CounterTransactionResponse `json:"transactions"`

	// UserId ID of the user
	UserId string `json:"user_id"`
}

// CounterTransactionResponse defines model for CounterTransactionResponse.
type CounterTransactionResponse struct {
	// Amount Amount added (positive) or deducted (negative)
	Amount int `json:"amount"`

	// BalanceAfter Balance after this transaction
	BalanceAfter int `json:"balance_after"`

	// CounterId ID of the counter type
	CounterId string `json:"counter_id"`

	// CreatedAt When the transaction was created
	CreatedAt time.Time `json:"created_at"`

	// Description Description of the transaction
	Description string `json:"description"`

	// Id Transaction ID
	Id string `json:"id"`

	// UserId ID of the user
	UserId string `json:"user_id"`
}

// Error defines model for Error.
type Error struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Database struct {
		// OpenConnections Number of open database connections
		OpenConnections *int   `json:"open_connections,omitempty"`
		Status          string `json:"status"`
	} `json:"database"`
	Status    string    `json:"status"`
	Timestamp time.Time `json:"timestamp"`

	// Uptime Server uptime duration
	Uptime string `json:"uptime"`
}

// RequestDetail defines model for RequestDetail.
type RequestDetail struct {
	Browser string `json:"browser"`

	// BrowserVersion Version of the browser
	BrowserVersion string `json:"browser_version"`
	City           string `json:"city"`
	Country        string `json:"country"`
	DeviceType     string `json:"device_type"`
	Id             string `json:"id"`

	// Latitude GPS latitude coordinate
	Latitude *float32 `json:"latitude"`

	// Longitude GPS longitude coordinate
	Longitude *float32 `json:"longitude"`

	// Path The requested URL path
	Path     string `json:"path"`
	Platform string `json:"platform"`

	// PlatformVersion Version of the operating system/platform
	PlatformVersion string    `json:"platform_version"`
	ResponseSize    float32   `json:"response_size"`
	ResponseTime    float32   `json:"response_time"`
	StatusCode      int       `json:"status_code"`
	Timestamp       time.Time `json:"timestamp"`

	// UserId ID of the authenticated user making the request
	UserId *string `json:"user_id"`

	// Username Username of the authenticated user making the request
	Username *string `json:"username"`
}

// RequestDetailsResponse defines model for RequestDetailsResponse.
type RequestDetailsResponse struct {
	Requests []RequestDetail `json:"requests"`
}

// RequestStatistics defines model for RequestStatistics.
type RequestStatistics struct {
	// AverageResponseSize Average response size in bytes
	AverageResponseSize float32 `json:"averageResponseSize"`

	// AverageResponseTime Average response time in milliseconds
	AverageResponseTime float32 `json:"averageResponseTime"`

	// RequestsByBrowser Number of requests grouped by browser
	RequestsByBrowser map[string]int `json:"requestsByBrowser"`

	// RequestsByCountry Number of requests grouped by country code
	RequestsByCountry map[string]int `json:"requestsByCountry"`

	// RequestsByDeviceType Number of requests grouped by device type
	RequestsByDeviceType map[string]int `json:"requestsByDeviceType"`

	// RequestsByJA4Fingerprint Number of requests grouped by JA4 HTTP fingerprint
	RequestsByJA4Fingerprint map[string]int `json:"requestsByJA4Fingerprint"`

	// RequestsByPlatform Number of requests grouped by platform
	RequestsByPlatform map[string]int `json:"requestsByPlatform"`

	// RequestsByStatus Number of requests grouped by HTTP status code
	RequestsByStatus map[string]int `json:"requestsByStatus"`

	// RequestsByUser Number of requests grouped by user (username or user ID)
	RequestsByUser map[string]int `json:"requestsByUser"`

	// TotalRequests Total number of requests
	TotalRequests int `json:"totalRequests"`
}

// TokenCreateRequest defines model for TokenCreateRequest.
type TokenCreateRequest struct {
	// ExpiresAt When the token should expire (null for no expiration)
	ExpiresAt *time.Time `json:"expires_at"`

	// Name User-defined name for the token
	Name string `json:"name"`

	// Scopes Permissions/scopes for the token
	Scopes *[]string `json:"scopes,omitempty"`
}

// TokenCreateResponse defines model for TokenCreateResponse.
type TokenCreateResponse struct {
	// Token The actual token string (only returned on creation)
	Token     string        `json:"token"`
	TokenInfo TokenResponse `json:"token_info"`
}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	// CreatedAt When the token was created
	CreatedAt time.Time `json:"created_at"`

	// ExpiresAt When the token expires (null if no expiration)
	ExpiresAt *time.Time `json:"expires_at"`

	// Id Unique identifier for the token
	Id string `json:"id"`

	// IsActive Whether the token is active
	IsActive bool `json:"is_active"`

	// LastUsedAt When the token was last used
	LastUsedAt *time.Time `json:"last_used_at"`

	// Name User-defined name for the token
	Name string `json:"name"`

	// RevokedAt When the token was revoked (null if not revoked)
	RevokedAt *time.Time `json:"revoked_at"`

	// Scopes Permissions/scopes for the token
	Scopes []string `json:"scopes"`

	// UsageCount Number of times the token has been used
	UsageCount int `json:"usage_count"`
}

// UserCountersResponse defines model for UserCountersResponse.
type UserCountersResponse struct {
	// Balance Current counter balance
	Balance int `json:"balance"`

	// CounterId ID of the counter type
	CounterId string `json:"counter_id"`

	// Email Email of the user
	Email *openapi_types.Email `json:"email,omitempty"`

	// LastUpdated When the balance was last updated
	LastUpdated time.Time `json:"last_updated"`

	// UserId ID of the user
	UserId string `json:"user_id"`

	// Username Username of the user
	Username *string `json:"username,omitempty"`
}

// UserCreateRequest defines model for UserCreateRequest.
type UserCreateRequest struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
	Username string              `json:"username"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
	CreatedAt time.Time            `json:"createdAt"`
	Email     *openapi_types.Email `json:"email,omitempty"`
	Id        string               `json:"id"`
	Name      *string              `json:"name"`
	Picture   *string              `json:"picture"`
	Provider  *string              `json:"provider"`
	UpdatedAt time.Time            `json:"updatedAt"`
	Username  string               `json:"username"`
}

// GetAllUserCountersParams defines parameters for GetAllUserCounters.
type GetAllUserCountersParams struct {
	// Limit Maximum number of users to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of users to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetUserCounterHistoryParams defines parameters for GetUserCounterHistory.
type GetUserCounterHistoryParams struct {
	// Limit Maximum number of transactions to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of transactions to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetRequestStatisticsParams defines parameters for GetRequestStatistics.
type GetRequestStatisticsParams struct {
	// StartDate Start date for filtering results (ISO 8601 format)
	StartDate *time.Time `form:"start_date,omitempty" json:"start_date,omitempty"`

	// EndDate End date for filtering results (ISO 8601 format)
	EndDate *time.Time `form:"end_date,omitempty" json:"end_date,omitempty"`
}

// GetRequestDetailsParams defines parameters for GetRequestDetails.
type GetRequestDetailsParams struct {
	// StartDate Optional start date for filtering results (ISO 8601 format)
	StartDate *time.Time `form:"start_date,omitempty" json:"start_date,omitempty"`

	// EndDate Optional end date for filtering results (ISO 8601 format)
	EndDate *time.Time `form:"end_date,omitempty" json:"end_date,omitempty"`
}

// LogoutUserParams defines parameters for LogoutUser.
type LogoutUserParams struct {
	// Redirect URL to redirect to after successful logout
	Redirect *string `form:"redirect,omitempty" json:"redirect,omitempty"`

	// TgSessionToken Session token cookie for authentication
	TgSessionToken *string `form:"tg_session_token,omitempty" json:"tg_session_token,omitempty"`
}

// AdjustUserCountersJSONRequestBody defines body for AdjustUserCounters for application/json ContentType.
type AdjustUserCountersJSONRequestBody = CounterAdjustmentRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserCreateRequest

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = TokenCreateRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAvailableCounters request
	GetAvailableCounters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllUserCounters request
	GetAllUserCounters(ctx context.Context, counterId string, params *GetAllUserCountersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserCounters request
	GetUserCounters(ctx context.Context, counterId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdjustUserCountersWithBody request with any body
	AdjustUserCountersWithBody(ctx context.Context, counterId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdjustUserCounters(ctx context.Context, counterId string, userId string, body AdjustUserCountersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserCounterHistory request
	GetUserCounterHistory(ctx context.Context, counterId string, userId string, params *GetUserCounterHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestStatistics request
	GetRequestStatistics(ctx context.Context, params *GetRequestStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestDetails request
	GetRequestDetails(ctx context.Context, params *GetRequestDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetToken request
	GetToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserById request
	GetUserById(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokens request
	ListTokens(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, userId string, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogoutUser request
	LogoutUser(ctx context.Context, params *LogoutUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenApiYaml request
	GetOpenApiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAvailableCounters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableCountersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllUserCounters(ctx context.Context, counterId string, params *GetAllUserCountersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllUserCountersRequest(c.Server, counterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserCounters(ctx context.Context, counterId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserCountersRequest(c.Server, counterId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdjustUserCountersWithBody(ctx context.Context, counterId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdjustUserCountersRequestWithBody(c.Server, counterId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdjustUserCounters(ctx context.Context, counterId string, userId string, body AdjustUserCountersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdjustUserCountersRequest(c.Server, counterId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserCounterHistory(ctx context.Context, counterId string, userId string, params *GetUserCounterHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserCounterHistoryRequest(c.Server, counterId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestStatistics(ctx context.Context, params *GetRequestStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestStatisticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestDetails(ctx context.Context, params *GetRequestDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequest(c.Server, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserById(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserByIdRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokens(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, userId string, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogoutUser(ctx context.Context, params *LogoutUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenApiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenApiYamlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAvailableCountersRequest generates requests for GetAvailableCounters
func NewGetAvailableCountersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/admin/counters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllUserCountersRequest generates requests for GetAllUserCounters
func NewGetAllUserCountersRequest(server string, counterId string, params *GetAllUserCountersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "counterId", runtime.ParamLocationPath, counterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/admin/counters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserCountersRequest generates requests for GetUserCounters
func NewGetUserCountersRequest(server string, counterId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "counterId", runtime.ParamLocationPath, counterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/counters/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdjustUserCountersRequest calls the generic AdjustUserCounters builder with application/json body
func NewAdjustUserCountersRequest(server string, counterId string, userId string, body AdjustUserCountersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdjustUserCountersRequestWithBody(server, counterId, userId, "application/json", bodyReader)
}

// NewAdjustUserCountersRequestWithBody generates requests for AdjustUserCounters with any type of body
func NewAdjustUserCountersRequestWithBody(server string, counterId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "counterId", runtime.ParamLocationPath, counterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/counters/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserCounterHistoryRequest generates requests for GetUserCounterHistory
func NewGetUserCounterHistoryRequest(server string, counterId string, userId string, params *GetUserCounterHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "counterId", runtime.ParamLocationPath, counterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/counters/%s/%s/history", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequestStatisticsRequest generates requests for GetRequestStatistics
func NewGetRequestStatisticsRequest(server string, params *GetRequestStatisticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/statistics/requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequestDetailsRequest generates requests for GetRequestDetails
func NewGetRequestDetailsRequest(server string, params *GetRequestDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/statistics/requests/details")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenRequest generates requests for GetToken
func NewGetTokenRequest(server string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserByIdRequest generates requests for GetUserById
func NewGetUserByIdRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTokensRequest generates requests for ListTokens
func NewListTokensRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/users/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, userId string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/users/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutUserRequest generates requests for LogoutUser
func NewLogoutUserRequest(server string, params *LogoutUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.TgSessionToken != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "tg_session_token", runtime.ParamLocationCookie, *params.TgSessionToken)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "tg_session_token",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenApiYamlRequest generates requests for GetOpenApiYaml
func NewGetOpenApiYamlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAvailableCountersWithResponse request
	GetAvailableCountersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAvailableCountersResponse, error)

	// GetAllUserCountersWithResponse request
	GetAllUserCountersWithResponse(ctx context.Context, counterId string, params *GetAllUserCountersParams, reqEditors ...RequestEditorFn) (*GetAllUserCountersResponse, error)

	// GetUserCountersWithResponse request
	GetUserCountersWithResponse(ctx context.Context, counterId string, userId string, reqEditors ...RequestEditorFn) (*GetUserCountersResponse, error)

	// AdjustUserCountersWithBodyWithResponse request with any body
	AdjustUserCountersWithBodyWithResponse(ctx context.Context, counterId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdjustUserCountersResponse, error)

	AdjustUserCountersWithResponse(ctx context.Context, counterId string, userId string, body AdjustUserCountersJSONRequestBody, reqEditors ...RequestEditorFn) (*AdjustUserCountersResponse, error)

	// GetUserCounterHistoryWithResponse request
	GetUserCounterHistoryWithResponse(ctx context.Context, counterId string, userId string, params *GetUserCounterHistoryParams, reqEditors ...RequestEditorFn) (*GetUserCounterHistoryResponse, error)

	// GetRequestStatisticsWithResponse request
	GetRequestStatisticsWithResponse(ctx context.Context, params *GetRequestStatisticsParams, reqEditors ...RequestEditorFn) (*GetRequestStatisticsResponse, error)

	// GetRequestDetailsWithResponse request
	GetRequestDetailsWithResponse(ctx context.Context, params *GetRequestDetailsParams, reqEditors ...RequestEditorFn) (*GetRequestDetailsResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// GetTokenWithResponse request
	GetTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*GetTokenResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// GetUserByIdWithResponse request
	GetUserByIdWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserByIdResponse, error)

	// ListTokensWithResponse request
	ListTokensWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ListTokensResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, userId string, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// LogoutUserWithResponse request
	LogoutUserWithResponse(ctx context.Context, params *LogoutUserParams, reqEditors ...RequestEditorFn) (*LogoutUserResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// GetOpenApiYamlWithResponse request
	GetOpenApiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiYamlResponse, error)
}

type GetAvailableCountersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AvailableCountersResponse
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAvailableCountersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableCountersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllUserCountersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllUserCountersResponse
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAllUserCountersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllUserCountersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserCountersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserCountersResponse
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserCountersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserCountersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdjustUserCountersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CounterTransactionResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AdjustUserCountersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdjustUserCountersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserCounterHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CounterHistoryResponse
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserCounterHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserCounterHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestStatistics
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRequestStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestDetailsResponse
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetRequestDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserResponse
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UserResponse
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TokenResponse
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TokenCreateResponse
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthResponse
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Authenticated *bool                `json:"authenticated,omitempty"`
		Email         *openapi_types.Email `json:"email,omitempty"`
		FamilyName    *string              `json:"familyName"`
		GivenName     *string              `json:"givenName"`
		IsAdmin       *bool                `json:"isAdmin,omitempty"`
		Name          *string              `json:"name"`
		Picture       *string              `json:"picture"`
		Provider      *string              `json:"provider,omitempty"`
		Timestamp     *time.Time           `json:"timestamp,omitempty"`
		Username      *string              `json:"username,omitempty"`
	}
	JSON401 *Error
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenApiYamlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML200      *string
}

// Status returns HTTPResponse.Status
func (r GetOpenApiYamlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenApiYamlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAvailableCountersWithResponse request returning *GetAvailableCountersResponse
func (c *ClientWithResponses) GetAvailableCountersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAvailableCountersResponse, error) {
	rsp, err := c.GetAvailableCounters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableCountersResponse(rsp)
}

// GetAllUserCountersWithResponse request returning *GetAllUserCountersResponse
func (c *ClientWithResponses) GetAllUserCountersWithResponse(ctx context.Context, counterId string, params *GetAllUserCountersParams, reqEditors ...RequestEditorFn) (*GetAllUserCountersResponse, error) {
	rsp, err := c.GetAllUserCounters(ctx, counterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllUserCountersResponse(rsp)
}

// GetUserCountersWithResponse request returning *GetUserCountersResponse
func (c *ClientWithResponses) GetUserCountersWithResponse(ctx context.Context, counterId string, userId string, reqEditors ...RequestEditorFn) (*GetUserCountersResponse, error) {
	rsp, err := c.GetUserCounters(ctx, counterId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserCountersResponse(rsp)
}

// AdjustUserCountersWithBodyWithResponse request with arbitrary body returning *AdjustUserCountersResponse
func (c *ClientWithResponses) AdjustUserCountersWithBodyWithResponse(ctx context.Context, counterId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdjustUserCountersResponse, error) {
	rsp, err := c.AdjustUserCountersWithBody(ctx, counterId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdjustUserCountersResponse(rsp)
}

func (c *ClientWithResponses) AdjustUserCountersWithResponse(ctx context.Context, counterId string, userId string, body AdjustUserCountersJSONRequestBody, reqEditors ...RequestEditorFn) (*AdjustUserCountersResponse, error) {
	rsp, err := c.AdjustUserCounters(ctx, counterId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdjustUserCountersResponse(rsp)
}

// GetUserCounterHistoryWithResponse request returning *GetUserCounterHistoryResponse
func (c *ClientWithResponses) GetUserCounterHistoryWithResponse(ctx context.Context, counterId string, userId string, params *GetUserCounterHistoryParams, reqEditors ...RequestEditorFn) (*GetUserCounterHistoryResponse, error) {
	rsp, err := c.GetUserCounterHistory(ctx, counterId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserCounterHistoryResponse(rsp)
}

// GetRequestStatisticsWithResponse request returning *GetRequestStatisticsResponse
func (c *ClientWithResponses) GetRequestStatisticsWithResponse(ctx context.Context, params *GetRequestStatisticsParams, reqEditors ...RequestEditorFn) (*GetRequestStatisticsResponse, error) {
	rsp, err := c.GetRequestStatistics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestStatisticsResponse(rsp)
}

// GetRequestDetailsWithResponse request returning *GetRequestDetailsResponse
func (c *ClientWithResponses) GetRequestDetailsWithResponse(ctx context.Context, params *GetRequestDetailsParams, reqEditors ...RequestEditorFn) (*GetRequestDetailsResponse, error) {
	rsp, err := c.GetRequestDetails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestDetailsResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// GetTokenWithResponse request returning *GetTokenResponse
func (c *ClientWithResponses) GetTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*GetTokenResponse, error) {
	rsp, err := c.GetToken(ctx, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// GetUserByIdWithResponse request returning *GetUserByIdResponse
func (c *ClientWithResponses) GetUserByIdWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserByIdResponse, error) {
	rsp, err := c.GetUserById(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserByIdResponse(rsp)
}

// ListTokensWithResponse request returning *ListTokensResponse
func (c *ClientWithResponses) ListTokensWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ListTokensResponse, error) {
	rsp, err := c.ListTokens(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, userId string, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// LogoutUserWithResponse request returning *LogoutUserResponse
func (c *ClientWithResponses) LogoutUserWithResponse(ctx context.Context, params *LogoutUserParams, reqEditors ...RequestEditorFn) (*LogoutUserResponse, error) {
	rsp, err := c.LogoutUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutUserResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// GetOpenApiYamlWithResponse request returning *GetOpenApiYamlResponse
func (c *ClientWithResponses) GetOpenApiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiYamlResponse, error) {
	rsp, err := c.GetOpenApiYaml(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenApiYamlResponse(rsp)
}

// ParseGetAvailableCountersResponse parses an HTTP response from a GetAvailableCountersWithResponse call
func ParseGetAvailableCountersResponse(rsp *http.Response) (*GetAvailableCountersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableCountersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AvailableCountersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllUserCountersResponse parses an HTTP response from a GetAllUserCountersWithResponse call
func ParseGetAllUserCountersResponse(rsp *http.Response) (*GetAllUserCountersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllUserCountersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllUserCountersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserCountersResponse parses an HTTP response from a GetUserCountersWithResponse call
func ParseGetUserCountersResponse(rsp *http.Response) (*GetUserCountersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserCountersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserCountersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAdjustUserCountersResponse parses an HTTP response from a AdjustUserCountersWithResponse call
func ParseAdjustUserCountersResponse(rsp *http.Response) (*AdjustUserCountersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdjustUserCountersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CounterTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserCounterHistoryResponse parses an HTTP response from a GetUserCounterHistoryWithResponse call
func ParseGetUserCounterHistoryResponse(rsp *http.Response) (*GetUserCounterHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserCounterHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CounterHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRequestStatisticsResponse parses an HTTP response from a GetRequestStatisticsWithResponse call
func ParseGetRequestStatisticsResponse(rsp *http.Response) (*GetRequestStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRequestDetailsResponse parses an HTTP response from a GetRequestDetailsWithResponse call
func ParseGetRequestDetailsResponse(rsp *http.Response) (*GetRequestDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTokenResponse parses an HTTP response from a GetTokenWithResponse call
func ParseGetTokenResponse(rsp *http.Response) (*GetTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserByIdResponse parses an HTTP response from a GetUserByIdWithResponse call
func ParseGetUserByIdResponse(rsp *http.Response) (*GetUserByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTokensResponse parses an HTTP response from a ListTokensWithResponse call
func ParseListTokensResponse(rsp *http.Response) (*ListTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TokenCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLogoutUserResponse parses an HTTP response from a LogoutUserWithResponse call
func ParseLogoutUserResponse(rsp *http.Response) (*LogoutUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Authenticated *bool                `json:"authenticated,omitempty"`
			Email         *openapi_types.Email `json:"email,omitempty"`
			FamilyName    *string              `json:"familyName"`
			GivenName     *string              `json:"givenName"`
			IsAdmin       *bool                `json:"isAdmin,omitempty"`
			Name          *string              `json:"name"`
			Picture       *string              `json:"picture"`
			Provider      *string              `json:"provider,omitempty"`
			Timestamp     *time.Time           `json:"timestamp,omitempty"`
			Username      *string              `json:"username,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetOpenApiYamlResponse parses an HTTP response from a GetOpenApiYamlWithResponse call
func ParseGetOpenApiYamlResponse(rsp *http.Response) (*GetOpenApiYamlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenApiYamlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest string
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}
